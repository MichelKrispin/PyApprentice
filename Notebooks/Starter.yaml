cells:
- check: "def _Check(scope, output):\n  if 'Hello, World!' in output:\n    return\
    \ True, 'Ganz sicher.'\n  elif 'Traceback' in output:\n    return False, 'Wenigstens\
    \ wei\xDFt Du jetzt wie ein Python Fehler aussieht.'\n  else:\n    return False,\
    \ 'Und so sieht es aus, wenn das Ergebnis noch nicht stimmt.'"
  code: print('Hello, World'
  id: 0
  output: ''
  response:
    display: none
    message: ''
  text: "Aller Anfang ist leicht. Ist eine alte chinesische Weisheit.\n\nDer typische\
    \ Anfang ist ein `Hello, World` Programm. Und wir k\xF6nnen gleich mal testen,\
    \ ob alles so funktioniert wie es sollte. Oben rechts ist ein `Run`-Button. W\xFC\
    rde ich ja mal drauf dr\xFCcken.\nDann sollte ein Fehler kommen. In der Fehlermeldung\
    \ selbst sollte irgendwas darauf hinweisen, dass eine Klammer fehlt (naja, zumindest\
    \ angedeutet). Die muss ganz hinten eingef\xFCgt werden, hinter dem rechten Anf\xFC\
    hrungszeichen.\n\nUnd wenn jetzt nochmal der Code ausgef\xFChrt wird, dann sollte\
    \ das Ergebnis orange werden. Das liegt daran, dass f\xFCr ein Weiterkommen `Hello,\
    \ World!` ausgegeben werden. (Ausrufezeichen hinter das d *zwinker zwinker*)"
  title: Start
- check: |-
    def _Check(scope, output):
      if 'message' in scope.keys() and 'Hallo' in output:
        return True, 'Ganz sicher.'
      else:
        return False, 'Versuch es doch einfach nochmal.'
  code: |-
    # Diese Zeile beschreibt nur etwas (und das nicht sehr gut...)
    # message = 'Hallo'
    # print(message)  # Hier wird wieder etwas ausgegeben
  id: 1
  output: ''
  response:
    display: none
    message: ''
  text: "Wir fangen mal klein an.\nCode wird immer Zeile f\xFCr Zeile geschrieben\
    \ und in Python muss\njede Zeile korrekt einger\xFCckt werden (also im MOment\
    \ noch ganz links anfangen)\nWenn vor einer Zeile ein `#` steht, dann ist diese\
    \ Zeile auskommentiert und wird ignoriert.\n\nMache aus den richtigen Zeilen wieder\
    \ Code, der nicht als Kommentar interpretiert wird,\nindem die \xB4#\xB4 an den\
    \ richtigen Stellen entfernt werden\n(und dann auch die Leerzeichen direkt dahinter;\
    \ Stichwort ganz links anfangen)."
  title: Kommentare
- check: |-
    def _Check(scope, output):
      if 'mitesser' in scope.keys() and scope['mitesser'] == 5:
        return True, 'Locker flockig.'
      else:
        return False, 'Nicht so wirklich...'
  code: |-
    gericht = []
    gericht.append(10)  # Kosten vom ersten Gericht (10)
    gericht.append(15)  # Kosten vom zweiten
    gericht.append(8)   # Kosten vom dritten

    mitesser = 4  # Anzahl der Mitessenden
    kosten = gesamt_kosten(gerichte, mitesser)  # Berechne die Gesamtkosten aus
    print(kosten)  # Gebe die Kosten aus
  id: 2
  output: ''
  response:
    display: none
    message: ''
  text: "Wir fangen mal an, indem wir einen Taschenrechner bauen,\nder das bezahlte\
    \ Restaurantgeld durch die Anzahl der Personen teilt.\nWenn ein Essen 100\u20AC\
    \ gekostet hat und 10 Leute mitgegessen haben,\ndann kostet der Spa\xDF 10\u20AC\
    \ pro Person.\n\nDas Prinzip hier ist, dass der fertige Code hier einmal steht,\n\
    das hei\xDFt, dass er \xFCberflogen werden kann, aber was das alles hei\xDFt,\n\
    schauen wir uns danach im Detail an.\n\n(Ich k\xFCndige schonmal an, dass das\
    \ Beispiel etwas... 'konstruiert' ist.\nEs wird sp\xE4ter noch aufregender, aber\
    \ hier sehen wir schonmal alle wichtigen Teile.)\n\nDaf\xFCr kopier den folgenden\
    \ Code in das rechte 'Global Functions' Fenster (und \xFCberschreib alles andere\
    \ darin).\n```\ndef gesamt_kosten(self, gerichte, anzahl):\n    betrag = 0.0\n\
    \    for kosten in gerichte:\n        betrag += kosten\n    if betrag <= 0.0:\n\
    \        return 0.0\n    return betrag / anzahl\n```\n\nInsgesamt ist es wohl\
    \ sehr hilfreich mal an den einzelnen Werten (unter dem `---` Kommentar) herumzuspielen.\n\
    Also den Name vom Restaurant mal \xE4ndern, oder die Preise der einzelnen Gerichte.\n\
    Um hier weiterzukommen, m\xFCssen 5 Leute mitessen."
  title: Motivation
- check: "def _Check(scope, output):\n    if 'anzahl_pizzen' in scope.keys() and scope['anzahl_pizzen']\
    \ == 2:\n        return True, 'Wundervoll.'\n    elif 'Traceback' in output:\n\
    \        return False, 'Ich w\xFCrde ja eine Zahl hinter das Gleichzeichen schreiben'\n\
    \    elif 'anzahl_pizzen' in scope.keys():\n        return False, 'Jetzt muss\
    \ die Anzahl der Pizzen nur noch gleich zwei sein.'\n    else:\n        return\
    \ False, 'Fast.'"
  code: "anzahl_pizzen = \nprint(anzahl_pizzen)"
  id: 3
  output: ''
  response:
    display: none
    message: ''
  text: "Also das war ja total aufregend, aber was machte der ganze Quatsch da eigentlich?\n\
    \nSehr gute Frage. EIne aufmerksame Leserschat ist immer wichtig.\n\nWeil wir\
    \ nat\xFCrlich nicht \xFCbertreiben wollten machen wir Bibischritte. Wir suchen\
    \ uns kleine Dinge mit denen wir dann sp\xE4ter den Restaurantrechner zusammenbauen\
    \ k\xF6nnen. Und weil das ganze Programmierprinzip auf dem Zusammenbauen aus kleinen\
    \ Teilen basiert, kann man danach auch fast schon eine Webseite bauen. Oder Twitter.\
    \ Fast zumindest.\n\n#### Variablen\n\nEine Variable hei\xDFt Variable, weil sie\
    \ variabel ist. Klever, oder? Also ist das was, was sich ver\xE4ndern l\xE4sst.\
    \ Die Dinger sind so immer \xFCberall und verfolgen einen. Aber am meisten helfen\
    \ da Beispiele. Wir fangen einfach mal an mit einer Zahl. \n\nWir wollten eine\
    \ Variable haben die die Anzahl an Pizzen speichert, die wir heute noch essen\
    \ wollen. Da wir bescheiden sind reichen uns `2`. Und damit wir das dann auch\
    \ in der Ausgabe sehen wir das gleich danach ausgegeben."
  title: Bibischritte
- check: "def _Check(scope, output):\n    if 'kekse' in scope.keys() and scope['kekse']\
    \ == 7:\n        return True, 'Wirklich aufregend.'\n    elif 'Traceback' in output:\n\
    \        return False, 'Ich w\xFCrde ja eine Zahl hinter das Gleichzeichen schreiben'\n\
    \    else:\n        return False, 'Noch nicht ganz.'"
  code: "kekse = 5\nprint(kekse)\nkekse = \nprint(kekse)"
  id: 4
  output: ''
  response:
    display: none
    message: ''
  text: "Aber jetzt k\xF6nnen wir damit ja noch ein bisschen Spa\xDF haben. Der Clou\
    \ ist n\xE4mlich, dass wir die Variable mit der Zeit ver\xE4ndern k\xF6nnen.\n\
    Nehmen wir also mal eine andere und geben sie danach aus. Und dann ver\xE4ndern\
    \ wir sie.\n\nWas passiert jetzt also, wenn wir unten `kekse` auf `7` setzen?\
    \ Was geben wir dann wohl aus?"
  title: Bibischritte 2
- check: "def _Check(scope, output):\n    if 'nachricht' in scope.keys() and scope['nachricht']\
    \ == 'Moin':\n        return True, 'Locker flockig.'\n    elif 'Traceback' in\
    \ output:\n        return False, 'Ich w\xFCrde ja eine Zahl hinter das Gleichzeichen\
    \ schreiben'\n    elif 'Hallo' in output:\n        return False, 'Na. Es muss\
    \ ja Moin ausgeben.'\n    elif 'message' in scope.keys():\n        return False,\
    \ 'Die Variable sollte wohl nachricht hei\xDFen.'\n    else:\n        return False,\
    \ 'Noch nicht ganz.'"
  code: |-
    message = 'Huhu'
    print(message)
  id: 5
  output: ''
  response:
    display: none
    message: ''
  text: "Naja und das ist das Grundprinzip. Aber es gibt nat\xFCrlich auch noch andere\
    \ Typen. Bisher hatten wir ja nur ganze Zahlen (Integer oder int; je nachdem).\
    \ Aber was macht Twitter blo\xDF? Da ist ja alles voller Text. Gute Frage.\n\n\
    Naja. Es gibt zum Gl\xFCck auch Textwerte (Strings oder str). Die sind innerhalb\
    \ von Anf\xFChrungsstrichen. Also ist bei `print('Hallo')` `'Hallo'` ein String.\
    \ Und damit wir den abspeichern k\xF6nnen, schreiben wir ihn hinter einen Variablennamen\
    \ wie vorher.\n\nUm es jetzt aber etwas aufregender zu machen, muss selbst eine\
    \ Variable geschrieben werden. Es wird gesucht: Eine Variable mit dem Namen `nachricht`\
    \ und sie muss den Inhalt `Moin` ausgeben."
  title: Mehr Bibischritte
- check: "def _Check(scope, output):\n    if 'pizza' in scope.keys() and 'gemuese'\
    \ in scope.keys() and 'gesamt' in scope.keys():\n      if (scope['pizza'] == 5.99\
    \ and scope['gemuese'] == 1.99 and\n          scope['pizza'] + scope['gemuese]\
    \ == scope['gesamt']:\n        return True, 'Daf\xFCr kannst Du Dir jetzt aber\
    \ auch mal auf die Schulter klopfen.'\n    elif 'Traceback' in output:\n     \
    \   return False, 'Da scheint irgendwas kaputt gegangen zu sein.'\n    elif 'p'\
    \ in scope.keys() or 'g' in scope.keys() or 'o' in scope.keys():\n        return\
    \ False, 'So wie es aussieht haben die Variablen noch nicht die richtigen Namen.'\
    \ \n    else:\n        return False, 'Und so sieht es aus, wenn es noch nicht\
    \ ganz richtig ist.'"
  code: "p = \ng = \no = p + g"
  id: 6
  output: ''
  response:
    display: none
    message: ''
  text: "Und daneben gibt es auch Kommazahlen. Schlie\xDFlich besteht die Welt nicht\
    \ nur aus ganzen Zahlen und Text. Wenn wir 5 Euro durch drei teilen, muss jeder\
    \ schlie\xDFlich 2,50 zahlen.\n\nDie Dinger hei\xDFen Float oder floating point\
    \ number, denn das Komma \"fliegt\". Mehr oder weniger... Das liegt eben daran,\
    \ dass z.B. bei der Zahl 2,5 das Komma an der zweiten Stelle steht, w\xE4hrend\
    \ es bei 22,5 an der dritten Stelle steht. Das Komma kann sich frei bewegen. Aber\
    \ das ist eher Nebensache.\n\nEins noch: Im Englischen wird \"zwei komma f\xFC\
    nf\" zu \"two point five\". Deshalb wird eine Kommazahl mit einem Punkt dazwischen\
    \ geschrieben und nicht mit einem Komma.\n\nAlso brauchen wir dieses Mal:\n- eine\
    \ Variable `pizza` mit dem Wert `5.99`\n- eine Variable `gemuese` mit dem Wert\
    \ `1.99` (ich w\xFCrde keine Sonderzeichen in die Variablen schreiben. Im Englischen\
    \ sind die meist nicht so gut darin an andere Sprachen zu denken...)\n- eine Variable\
    \ `gesamt` mit dem Wert `pizza + gemuese` (niemand rechnet selbst, wenn ein Computer\
    \ zur Stelle ist)."
  title: Float
- check: |-
    def _Check(scope, output):
        if ('cool' in scope.keys() and 'uncool' in scope.keys() and
            scope['cool'] == True and scope['uncool'] == False):
            return True, 'Und das sind Variablen mit dem Typ bool.'
        elif 'Traceback' in output:
            return False, 'Oh oh. Was ist denn hier kaputt gegangen?'
        else:
            return False, 'Und so sieht es wieder aus, wenn es noch nicht ganz richtig ist.'
  code: print('Bitte ersetze mich')
  id: 7
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt gibt es noch einen aufregenden Grundtyp, den wir uns noch anschauen\
    \ m\xFCssen. Das Ding hei\xDFt Bool(nach einem englischen Mathematiker Boole;\
    \ das e wurde irgendwann unterschlagen...).\nEin Bool kann nur zwei Werte annehmen:\
    \ Wahr oder Falsch. Nichts anderes.\nKlingt erstmal nicht aufregend, kann es auch\
    \ sein, muss es aber nicht.\n\nAlso bauen wir uns erstmal zwei davon:\n`cool`\
    \ mit dem Wert `True` (achte auf Gro\xDFschreibung), und `uncool` mit dem Wert\
    \ `False`."
  title: Wahr oder Falsch
- check: "def _Check(scope, output):\n    if ('False' in output and all([e in scope.keys()\
    \ for e in 'abc']) and\n        (scope['a'] == scope['b'] == scope['c']) == False):\n\
    \        return True, 'Upsi pupsi war wohl zu einfach dupsi.'\n    elif 'Traceback'\
    \ in output:\n        return False, 'Oh oh. Kapuff.'\n    else:\n        return\
    \ False, 'An der L\xF6sung w\xFCrde ich nochmal feilschen.'"
  code: "a = \nb = \nc = \nprint(a == b)"
  id: 8
  output: ''
  response:
    display: none
    message: ''
  text: "Bisher haben wir immer nur Sachen gemacht die auf jeden Fall passieren. Ist\
    \ ja eigentlich nicht so aufregend. Man startet das Programm und es f\xFChrt immer\
    \ alles aus. Noch nicht so spannend. Aber fangen wir mal an den Teil von eben\
    \ zu nutzen. Warum brauchen wir Werte die Wahr oder Falsch sein k\xF6nnen? Aufmerksame\
    \ Leserschaft. Immer wichtig!\n\nDamit wir den Programmfluss \xE4ndern k\xF6nnen.\
    \ Stellen wir uns ein Twitter vor, in dem alle, die ein 'schwabbel' im Usernamen\
    \ haben, geblockt werden. Um das aufzubauen, m\xFCssen wir Dinge vergleichen k\xF6\
    nnen. Hier konkret so etwas wie: _\"Hat user x 'schwabbel' im Namen\"_.\n\nWir\
    \ fangen nat\xFCrlich wieder klein an. Nehmen wir uns wieder zwei boolsche Variablen\
    \ wie eben und vergleichen sie.\nEs gibt mehrere Vergleiche:\n- `==` ist gleich?\
    \ (zwei Gleichheitszeichen, weil eins ja f\xFCr das Zuweisen ist; `a = 5`)\n--\
    \ `5 == 5` ergibt `True`\n-- `5 == 4` ergibt `False`\n-- `False == True` ergibt\
    \ `False`\n- `!=` ist ungleich?\n-- `5 != 5` eribt `False` (also das genaue Gegenteil\
    \ von `==` eben...)\n- `>`  ist links gr\xF6\xDFer als rechts?\n-- `5 > 5` ergibt\
    \ `False` (gr\xF6\xDFer *als*)\n-- `5 > 4` ergibt `True`\n- `>=` ist links gr\xF6\
    \xDFer gleich rechts?\n-- `5 > 5` ergibt `True` (gr\xF6\xDFer *gleich*)\n- `<`\
    \  ist links kleiner als rechts?\n-- `5 < 6` ergibt `True`\n- `<=` ist links kleiner\
    \ gleich rechts?\n-- Naja... Du wei\xDFt schon.\n\nEs hilft hier wieder einfach\
    \ mal herumzuspielen an den Werten und die Ausgaben zu \xFCberpr\xFCfen.\nUm weiterzukommen\
    \ suchen wir drei Variablen `a`, `b`, `c` (kreativ, nicht?) mit den jeweiligen\
    \ Werten `True`, `False`, `False` und ausgegeben werden muss was bei dem Vergleich\
    \ `a == b == c` herauskommt. Wir k\xF6nnen n\xE4mlich auch Vergleiche hintereinander\
    \ schachteln. Am wichtigsten wohl f\xFCr sowas wie `5 < etwas < 10`."
  title: Wahr oder Wahr
- check: |-
    def _Check(scope, output):
        if ('age' in scope.keys() and 'maximum_age' in scope.keys() and
            scope['age'] > scope['maximum_age']):
            return True, 'Das ist eine freie Plattform.'
        elif 'Traceback' in output:
            return False, 'Diese Plattform ist zur Zeit nicht erreichbar.'
        else:
            return False, 'Armer Bert.'
  code: |-
    message = 'Das ist eine freie Plattform'

    user = 'Bert'
    age = 31

    maximum_age = 30

    if age > maximum_age:
      print('-- Diese Nachricht wurde blockiert. --')
    else:
      print(message)
  id: 9
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt haben wir Vergleiche. Wir sind sooooo kurz davor etwas wirklich gro\xDF\
    artiges zu schaffen.\n\nWir k\xF6nnen jetzt n\xE4mlich... *Trommelwirbel*\n\n\
    Bedingungen einf\xFChren. Stellen wir uns vor, wir haben eine sehr restriktive\
    \ Social Media Plattform. Nicht so \"jeder darf alles schreiben\", sondern alle,\
    \ die \xE4lter als 30 sind werden zensiert. Unser Programm, unsere Regeln. Ist\
    \ ja klar.\n\nAlso:\nWir haben jetzt zwei M\xF6glichkeiten, um die Nachricht von\
    \ Bert anzuzeigen. Entweder er schummelt mit seinem wahren Alter (er sieht eh\
    \ aus wie 19), oder das Zensur-Alter wird angehoben. Freie Wahl. Denn das ist\
    \ eine (fast) freie Plattform."
  title: Rein hypothetisch
- check: |-
    def _Check(scope, output):
        if ('age' in scope.keys() and scope['age'] < 20 and
            'Jungspund.' in output):
            return True, 'Jung geblieben...'
        elif 'Traceback' in output:
            return False, 'Diese Plattform ist zur Zeit nicht erreichbar.'
        else:
            return False, 'Schon alt...'
  code: |-
    message = ''  # Leere Nachricht; Platzhalter

    age = 40

    if age < 20:
      message = 'Jungspund.'
    elif age < 30:
      message = 'Fast schon Oppa.'
    else:
      message = 'Rente steht an.'

    print(message)
  id: 10
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt k\xF6nnte es aber sein, dass wir den ganzen Spa\xDF noch etwas feiner\
    \ unterteilen wollen.\n\nWir haben zum Beispiel eine freie Plattform, die alle\
    \ Nutzer sofort in Schubladen steckt.\nWie gesagt: Unsere Plattform, unsere Regeln.\n\
    \nWir kategorisieren also mit was w\xE4re wenn hintereinander. Das funktioniert\
    \ mit `if` und `elif` danach f\xFCr \"else if\". Wenn das `if` nicht zutrifft,\
    \ dann wird das `elif` \xFCberpr\xFCft. Der wichtige Unterschied hier ist: Wenn\
    \ wir zwei `if` hintereinander stellen, werden beide auf jeden Fall \xFCberpr\xFC\
    ft. Auch wenn das erste wahr ist. Bei `elif` nicht.\n\nKonkret ist hier also Beispiel\
    \ A.\nDas Alter sollte so niedrig genug sein, damit der `'Jungspund.'` ausgegeben\
    \ wird."
  title: Hypothethisch Plus
- check: |-
    def _Check(scope, output):
        if ('age' in scope.keys() and scope['age'] < 20 and
            'Jungspund.' in output):
            return True, 'Locker flockig.'
        elif 'Traceback' in output:
            return False, 'Diese Plattform ist zur Zeit nicht erreichbar.'
        else:
            return False, 'Noch nicht ganz.'
  code: |-
    message = ''  # Leere Nachricht; Platzhalter

    age = 15

    if age < 20:
      message = 'Jungspund.'
    if age < 30:  # Kein else if
      message = 'Fast schon Oppa.'
    if age >= 30:  # Separates else
      message = 'Rente steht an.'

    print(message)
  id: 11
  output: ''
  response:
    display: none
    message: ''
  text: "Und jetzt mal ohne `elif`. Was passiert hier wohl, wenn das Alter wieder\
    \ kleiner als 20 ist? \n\nWas muss denn hier ge\xE4ndert werden, damit wir wieder\
    \ dieselbe Ausgabe wie vorher bekommen?"
  title: If if if
global-code: '# Hier kommen globale Funktionen rein'
passed: 0
title: Starterpack
