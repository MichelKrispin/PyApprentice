cells:
- check: |-
    def _Check(scope, output):
      if 'Traceback' in output:
        return False, 'Wenigstens wei\xDFt Du jetzt wie ein Python Fehler aussieht.'
      elif 'Hello, World!' in output:
        return True, 'Ganz sicher.'
      else:
        return False, 'Und so sieht es aus, wenn das Ergebnis noch nicht stimmt.'
  code: print('Hello, World'
  id: 0
  output: ''
  response:
    display: none
    message: ''
  text: "Aller Anfang ist leicht. Wie eine alte Weisheit besagt.\n\nDer typische Anfang\
    \ ist ein `Hello, World` Programm. Und wir k\xF6nnen gleich mal testen, ob alles\
    \ so funktioniert wie es sollte. Oben rechts ist ein `Run`-Button. W\xFCrde ich\
    \ ja mal drauf dr\xFCcken. (Oder, wenn der Cursor im Codeblock ist, Strg+Enter\
    \ dr\xFCcken)\n\nDann sollte ein Fehler kommen. In der Fehlermeldung selbst sollte\
    \ irgendwas darauf hinweisen, dass eine Klammer fehlt (naja, zumindest angedeutet).\
    \ Die muss ganz hinten eingef\xFCgt werden, hinter dem rechten Anf\xFChrungszeichen.\n\
    \nUnd wenn jetzt nochmal der Code ausgef\xFChrt wird, dann sollte das Ergebnis\
    \ orange werden. Das liegt daran, dass f\xFCr ein Weiterkommen `Hello, World!`\
    \ ausgegeben werden. (Ausrufezeichen hinter das d *zwinker zwinker*)"
  title: Start
- check: |-
    def _Check(scope, output):
      if 'Traceback' in output:
        return False, 'Das sieht noch nicht ganz richtig aus.'
      elif 'message' in scope.keys() and 'Hallo' in output:
        return True, 'Ganz sicher.'
      else:
        return False, 'Versuch es doch einfach nochmal.'
  code: |-
    # message = 'Hallo'
    # print(message)  # Hier wird wieder etwas ausgegeben
  id: 1
  output: ''
  response:
    display: none
    message: ''
  text: "Wir fangen mal klein an.\nCode wird immer Zeile f\xFCr Zeile geschrieben\
    \ und in Python muss\njede Zeile korrekt einger\xFCckt werden (also im Moment\
    \ noch ganz links anfangen)\nWenn vor einer Zeile ein `#` steht, dann ist diese\
    \ Zeile auskommentiert und wird ignoriert.\n\nMache aus den Zeilen wieder Code,\
    \ die nicht als Kommentar interpretiert werden,\nindem du die `#` wegnimmst."
  title: Kommentare
- check: |-
    def _Check(scope, output):
      if 'Traceback' in output:
        if 'Global Code' in output:
          return False, 'Da ist wohl was beim kopieren schief gegangen.'
        return False, 'Nope.'
      elif 'mitesser' in scope.keys() and scope['mitesser'] == 5:
        return True, 'Locker flockig.'
      else:
        return False, 'Nicht so wirklich...'
  code: |-
    gerichte = []
    gerichte.append(10)  # Kosten vom ersten Gericht (10)
    gerichte.append(15)  # Kosten vom zweiten
    gerichte.append(8)   # Kosten vom dritten

    mitesser = 4  # Anzahl der Mitessenden
    kosten = gesamt_kosten(gerichte, mitesser)  # Berechne die Gesamtkosten aus
    print(kosten)  # Gebe die Kosten aus
  id: 2
  output: ''
  response:
    display: none
    message: ''
  text: "Wir fangen mal an, indem wir einen Taschenrechner bauen,\nder das bezahlte\
    \ Restaurantgeld durch die Anzahl der Personen teilt.\nWenn ein Essen 100\u20AC\
    \ gekostet hat und 10 Leute mitgegessen haben,\ndann kostet der Spa\xDF 10\u20AC\
    \ pro Person.\n\nDas Prinzip hier ist, dass der fertige Code hier einmal steht,\n\
    das hei\xDFt, dass er \xFCberflogen werden kann, aber was das alles hei\xDFt,\n\
    schauen wir uns danach im Detail an.\n\n(Ich k\xFCndige schonmal an, dass das\
    \ Beispiel etwas... 'konstruiert' ist.\nEs wird sp\xE4ter noch aufregender, aber\
    \ hier sehen wir schonmal alle wichtigen Teile.)\n\nDaf\xFCr kopier den folgenden\
    \ Code in das rechte 'Global Functions' Fenster (und \xFCberschreib alles andere\
    \ darin).\n```\ndef gesamt_kosten(gerichte, anzahl):\n    betrag = 0.0\n    for\
    \ kosten in gerichte:\n        betrag += kosten\n    if betrag <= 0.0:\n     \
    \   return 0.0\n    return betrag / anzahl\n```\n\nZum Spa\xDF kannst Du ja mal\
    \ an den Kosten der verschiedenen Gerichte herumdrehen und schauen was dann herauskommt.\n\
    \n#### Weiterkommen\n\nUm hier weiterzukommen, m\xFCssen 5 Leute mitessen."
  title: Motivation
- check: |-
    def _Check(scope, output):
      if 'Traceback' in output:
        return False, 'Ich w\xFCrde ja eine Zahl hinter das Gleichzeichen schreiben'
      elif 'anzahl_pizzen' in scope.keys() and scope['anzahl_pizzen'] == 2:
        return True, 'Wundervoll.'
      elif 'anzahl_pizzen' in scope.keys():
        return False, 'Jetzt muss die Anzahl der Pizzen nur noch gleich zwei sein.'
      else:
        return False, 'Fast.'
  code: "anzahl_pizzen = \nprint(anzahl_pizzen)"
  id: 3
  output: ''
  response:
    display: none
    message: ''
  text: "Also das war ja total aufregend, aber was machte der ganze Quatsch da eigentlich?\n\
    \nSehr gute Frage. Eine aufmerksame Leserschaft ist immer wichtig.\n\nWeil wir\
    \ nat\xFCrlich nicht \xFCbertreiben wollten machen wir Bibischritte. Wir suchen\
    \ uns kleine Dinge mit denen wir dann sp\xE4ter den Restaurantrechner zusammenbauen\
    \ k\xF6nnen. Und weil das ganze Programmierprinzip auf dem Zusammenbauen aus kleinen\
    \ Teilen basiert, kann man danach auch fast schon eine Webseite bauen. Oder Twitter.\
    \ Fast zumindest.\n\n#### Variablen\n\nEine Variable hei\xDFt Variable, weil sie\
    \ variabel ist. Klever, oder? Also ist das was, was sich ver\xE4ndern l\xE4sst.\
    \ Die Dinger sind so immer \xFCberall und verfolgen einen. Aber am meisten helfen\
    \ da Beispiele. Wir fangen einfach mal an mit einer Zahl. \n\nWir wollten eine\
    \ Variable haben die die Anzahl an Pizzen speichert, die wir heute noch essen\
    \ wollen. Da wir bescheiden sind reichen uns `2`. Und damit wir das dann auch\
    \ in der Ausgabe sehen wir das gleich danach ausgegeben."
  title: Bibischritte
- check: "def _Check(scope, output):\n    if 'kekse' in scope.keys() and scope['kekse']\
    \ == 7:\n        return True, 'Wirklich aufregend.'\n    elif 'Traceback' in output:\n\
    \        return False, 'Ich w\xFCrde ja eine Zahl hinter das Gleichzeichen schreiben'\n\
    \    else:\n        return False, 'Noch nicht ganz.'"
  code: "kekse = 5\nprint(kekse)\nkekse = \nprint(kekse)"
  id: 4
  output: ''
  response:
    display: none
    message: ''
  text: "Aber jetzt k\xF6nnen wir damit ja noch ein bisschen Spa\xDF haben. Der Clou\
    \ ist n\xE4mlich, dass wir die Variable mit der Zeit ver\xE4ndern k\xF6nnen.\n\
    Nehmen wir also mal eine andere und geben sie danach aus. Und dann ver\xE4ndern\
    \ wir sie.\n\nWas passiert jetzt also, wenn wir das untere `kekse` auf `7` setzen?\
    \ Was geben wir dann wohl aus?"
  title: Bibischritte 2
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        if \"\
    name 'message' is not defined\" in output:\n            return False, 'Innerhalb\
    \ der Klammern sollte das wohl auch ausgetauscht werden.'\n        return False,\
    \ 'Ich w\xFCrde ja eine Zahl hinter das Gleichzeichen schreiben.'\n    elif 'nachricht'\
    \ in scope.keys() and scope['nachricht'] == 'Moin':\n        return True, 'Das\
    \ war ja schon etwas zu einfach.'\n    elif 'Hallo' in output:\n        return\
    \ False, 'Na. Es muss ja Moin ausgeben.'\n    elif 'message' in scope.keys():\n\
    \        return False, 'Die Variable sollte wohl nachricht hei\xDFen.'\n    else:\n\
    \        return False, 'Noch nicht ganz.'"
  code: |-
    message = 'Huhu'
    print(message)
  id: 5
  output: ''
  response:
    display: none
    message: ''
  text: "Naja und das ist das Grundprinzip. Aber es gibt nat\xFCrlich auch noch andere\
    \ Typen. Bisher hatten wir ja nur ganze Zahlen (Integer oder int; je nachdem).\
    \ Aber was macht Twitter blo\xDF? Da ist ja alles voller Text. Gute Frage.\n\n\
    Naja. Es gibt zum Gl\xFCck auch Textwerte (Strings oder str). Die sind innerhalb\
    \ von Anf\xFChrungsstrichen. Also ist bei `print('Hallo')` `'Hallo'` ein String.\
    \ Und damit wir den abspeichern k\xF6nnen, schreiben wir ihn hinter einen Variablennamen\
    \ wie vorher.\n\nAlso sind Variablen das Ding links vom `=` und das Ding, was\
    \ den Wert h\xE4lt. Die Namen daf\xFCr k\xF6nnen im Prinzip alles sein (Gro\xDF\
    -,Kleinbuchstaben,Zahlen und Unterstriche) solange sie nicht mit einer Zahl anfangen.\
    \ Z.B. `abc123`, `_wuff`, `Schwabb3l_bluB`...\n\nUm es jetzt aber etwas aufregender\
    \ zu machen, muss selbst eine Variable geschrieben werden. Es wird gesucht: Eine\
    \ Variable mit dem Namen `nachricht` und sie muss den Inhalt `Moin` ausgeben.\
    \ Das hei\xDFt hier, dass die Variable mit dem Namen `message` einen neuen Namen\
    \ braucht und der Wert ein neuer sein sollte."
  title: Mehr Bibischritte
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Da scheint irgendwas kaputt gegangen zu sein.'\n    elif ('pizza' in\
    \ scope.keys() and 'gemuese' in scope.keys() and 'gesamt' in scope.keys() and\n\
    \          scope['pizza'] == 5.99 and scope['gemuese'] == 1.99 and\n         \
    \ scope['pizza'] + scope['gemuese'] == scope['gesamt']):\n        return True,\
    \ 'Daf\xFCr kannst Du Dir jetzt aber auch mal auf die Schulter klopfen.'\n   \
    \ elif 'p' in scope.keys() or 'g' in scope.keys() or 'o' in scope.keys():\n  \
    \      return False, 'So wie es aussieht haben die Variablen noch nicht die richtigen\
    \ Namen.' \n    else:\n        return False, 'Und so sieht es aus, wenn es noch\
    \ nicht ganz richtig ist.'"
  code: "p = \ng = \no = p + g"
  id: 6
  output: ''
  response:
    display: none
    message: ''
  text: "Und daneben gibt es auch Kommazahlen. Schlie\xDFlich besteht die Welt nicht\
    \ nur aus ganzen Zahlen und Text. Wenn wir 5 Euro durch drei teilen, muss jeder\
    \ schlie\xDFlich 2,50 zahlen.\n\nDie Dinger hei\xDFen Float oder floating point\
    \ number, denn das Komma \"fliegt\". Mehr oder weniger... Das liegt eben daran,\
    \ dass z.B. bei der Zahl 2,5 das Komma an der zweiten Stelle steht, w\xE4hrend\
    \ es bei 22,5 an der dritten Stelle steht. Das Komma kann sich frei bewegen. Aber\
    \ das ist eher Nebensache.\n\nEins noch: Im Englischen wird \"zwei komma f\xFC\
    nf\" zu \"two point five\". Deshalb wird eine Kommazahl mit einem Punkt dazwischen\
    \ geschrieben und nicht mit einem Komma.\n\nAlso brauchen wir dieses Mal:\n- eine\
    \ Variable `pizza` mit dem Wert `5.99`\n- eine Variable `gemuese` mit dem Wert\
    \ `1.99` (ich w\xFCrde keine Sonderzeichen in die Variablen schreiben. Im Englischen\
    \ sind die meist nicht so gut darin an andere Sprachen zu denken...)\n- eine Variable\
    \ `gesamt` mit dem Wert `pizza + gemuese` (niemand rechnet selbst, wenn ein Computer\
    \ zur Stelle ist).\n\n(_Die bisherigen Variablennamen m\xFCssen alle ge\xE4ndert\
    \ werden und sind nur Platzhalter_)"
  title: Float
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Oh oh. Was ist denn hier kaputt gegangen?'
        elif ('cool' in scope.keys() and 'uncool' in scope.keys() and
            scope['cool'] == True and scope['uncool'] == False):
            return True, 'Und das sind Variablen mit dem Typ bool.'
        else:
            return False, 'Und so sieht es wieder aus, wenn es noch nicht ganz richtig ist.'
  code: print('Bitte ersetze mich')
  id: 7
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt gibt es noch einen aufregenden Grundtyp, den wir uns noch anschauen\
    \ m\xFCssen. Das Ding hei\xDFt Bool(nach einem englischen Mathematiker Boole;\
    \ das e wurde irgendwann unterschlagen...).\nEin Bool kann nur zwei Werte annehmen:\
    \ Wahr oder Falsch. Nichts anderes.\nKlingt erstmal nicht aufregend, kann es auch\
    \ sein, muss es aber nicht.\n\nAlso bauen wir uns erstmal zwei davon:\n`cool`\
    \ mit dem Wert `True` (achte auf Gro\xDFschreibung), und `uncool` mit dem Wert\
    \ `False`."
  title: Wahr oder Falsch
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Oh oh. Kapuff.'\n    elif ('False' in output and all([e in scope.keys()\
    \ for e in 'abc']) and\n        (scope['a'] == scope['b'] == scope['c']) == False):\n\
    \        return True, 'Upsi pupsi war wohl zu einfach dupsi.'\n    else:\n   \
    \     return False, 'An der L\xF6sung w\xFCrde ich nochmal feilschen.'"
  code: "a = \nb = \nc = \nprint(a == b)"
  id: 8
  output: ''
  response:
    display: none
    message: ''
  text: "Bisher haben wir immer nur Sachen gemacht die auf jeden Fall passieren. Ist\
    \ ja eigentlich nicht so aufregend. Man startet das Programm und es f\xFChrt immer\
    \ alles aus. Noch nicht so spannend. Aber fangen wir mal an den Teil von eben\
    \ zu nutzen. Warum brauchen wir Werte die Wahr oder Falsch sein k\xF6nnen? Aufmerksame\
    \ Leserschaft. Immer wichtig!\n\nDamit wir den Programmfluss \xE4ndern k\xF6nnen.\
    \ Stellen wir uns ein Twitter vor, in dem alle, die ein 'schwabbel' im Usernamen\
    \ haben, geblockt werden. Um das aufzubauen, m\xFCssen wir Dinge vergleichen k\xF6\
    nnen. Hier konkret so etwas wie: _\"Hat user x 'schwabbel' im Namen\"_.\n\nWir\
    \ fangen nat\xFCrlich wieder klein an. Nehmen wir uns wieder zwei boolsche Variablen\
    \ wie eben und vergleichen sie.\nEs gibt mehrere Vergleiche:\n- `==` ist gleich?\
    \ (zwei Gleichheitszeichen, weil eins ja f\xFCr das Zuweisen ist; `a = 5`)\n--\
    \ `5 == 5` ergibt `True`\n-- `5 == 4` ergibt `False`\n-- `False == True` ergibt\
    \ `False`\n- `!=` ist ungleich?\n-- `5 != 5` eribt `False` (also das genaue Gegenteil\
    \ von `==` eben...)\n- `>`  ist links gr\xF6\xDFer als rechts?\n-- `5 > 5` ergibt\
    \ `False` (gr\xF6\xDFer *als*)\n-- `5 > 4` ergibt `True`\n- `>=` ist links gr\xF6\
    \xDFer gleich rechts?\n-- `5 > 5` ergibt `True` (gr\xF6\xDFer *gleich*)\n- `<`\
    \  ist links kleiner als rechts?\n-- `5 < 6` ergibt `True`\n- `<=` ist links kleiner\
    \ gleich rechts?\n-- Naja... Du wei\xDFt schon.\n\nEs hilft hier wieder einfach\
    \ mal herumzuspielen an den Werten und die Ausgaben zu \xFCberpr\xFCfen.\nUm weiterzukommen\
    \ suchen wir drei Variablen `a`, `b`, `c` (kreativ, nicht?) mit den jeweiligen\
    \ Werten `True`, `False`, `False` und ausgegeben werden muss was bei dem Vergleich\
    \ `a == b == c` herauskommt. Wir k\xF6nnen n\xE4mlich auch Vergleiche hintereinander\
    \ schachteln. Am wichtigsten wohl f\xFCr sowas wie `5 < etwas < 10`."
  title: Wahr oder Wahr
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Diese Plattform ist zur Zeit nicht erreichbar.'
        elif ('age' in scope.keys() and 'maximum_age' in scope.keys() and
            scope['age'] < scope['maximum_age']):
            return True, 'Das ist eine freie Plattform.'
        else:
            return False, 'Armer Bert.'
  code: |-
    message = 'Das ist eine freie Plattform'

    user = 'Bert'
    age = 31

    maximum_age = 30

    if age > maximum_age:
      print('-- Diese Nachricht wurde blockiert. --')
    else:
      print(message)
  id: 9
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt haben wir Vergleiche. Wir sind sooooo kurz davor etwas wirklich gro\xDF\
    artiges zu schaffen.\n\nWir k\xF6nnen jetzt n\xE4mlich... *Trommelwirbel*\n\n\
    Bedingungen einf\xFChren. Stellen wir uns vor, wir haben eine sehr restriktive\
    \ Social Media Plattform. Nicht so \"jeder darf alles schreiben\", sondern alle,\
    \ die \xE4lter als 30 sind werden zensiert. Unser Programm, unsere Regeln. Ist\
    \ ja klar.\n\nAlso:\nWir haben jetzt zwei M\xF6glichkeiten, um die Nachricht von\
    \ Bert anzuzeigen. Entweder er schummelt mit seinem wahren Alter (er sieht eh\
    \ aus wie 19), oder das Zensur-Alter wird angehoben. Freie Wahl. Denn das ist\
    \ eine (fast) freie Plattform."
  title: Rein hypothetisch
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Diese Plattform ist zur Zeit nicht erreichbar.'
        elif ('age' in scope.keys() and scope['age'] < 20 and
            'Jungspund.' in output):
            return True, 'Jung geblieben...'
        else:
            return False, 'Schon alt...'
  code: |-
    message = ''  # Leere Nachricht; Platzhalter

    age = 40

    if age < 20:
      message = 'Jungspund.'
    elif age < 30:
      message = 'Fast schon Oppa.'
    else:
      message = 'Rente steht an.'

    print(message)
  id: 10
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt k\xF6nnte es aber sein, dass wir den ganzen Spa\xDF noch etwas feiner\
    \ unterteilen wollen.\n\nWir haben zum Beispiel eine freie Plattform, die alle\
    \ Nutzer sofort in Schubladen steckt.\nWie gesagt: Unsere Plattform, unsere Regeln.\n\
    \nWir kategorisieren also mit was w\xE4re wenn hintereinander. Das funktioniert\
    \ mit `if` und `elif` danach f\xFCr \"else if\". Wenn das `if` nicht zutrifft,\
    \ dann wird das `elif` \xFCberpr\xFCft. Der wichtige Unterschied hier ist: Wenn\
    \ wir zwei `if` hintereinander stellen, werden beide auf jeden Fall \xFCberpr\xFC\
    ft. Auch wenn das erste wahr ist. Bei `elif` nicht.\n\nKonkret ist hier also Beispiel\
    \ A.\nDas Alter sollte so niedrig genug sein, damit der `'Jungspund.'` ausgegeben\
    \ wird."
  title: Hypothethisch Plus
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Diese Plattform ist zur Zeit nicht erreichbar.'
        elif ('age' in scope.keys() and scope['age'] < 20 and
            'Jungspund.' in output):
            return True, 'Joa... Was soll man da noch sagen.'
        else:
            return False, 'Noch nicht ganz.'
  code: |-
    message = ''  # Leere Nachricht; Platzhalter

    age = 15

    if age < 20:
      message = 'Jungspund.'
    if age < 30:  # Kein else if
      message = 'Fast schon Oppa.'
    if age >= 30:  # Separates else
      message = 'Rente steht an.'

    print(message)
  id: 11
  output: ''
  response:
    display: none
    message: ''
  text: "Und jetzt mal ohne `elif`. Was passiert hier wohl, wenn das Alter wieder\
    \ kleiner als 20 ist? \n\nWas muss denn hier ge\xE4ndert werden, damit wir wieder\
    \ dieselbe Ausgabe wie vorher bekommen?"
  title: If if if
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Kaputt...'
        elif ('Nach Hause telefonieren' in output and 'max_messages' in scope.keys() and
            'message' in scope.keys() and 'number_messages' in scope.keys() and
            scope['number_messages'] < scope['max_messages'] and
            scope['number_messages'] == 5 and
            type(scope['number_messages']) == int):
            return True, 'Mal eben so.'
        else:
            return False, 'Ja, ne. Ne.'
  code: |-
    max_messages = 6

    # Hier fehlt wohl was

    if _:
      print()
  id: 12
  output: ''
  response:
    display: none
    message: ''
  text: "Was wissen wir eigentlich schon?\n\nDamit wir rekapitulieren, was schon alles\
    \ programmiert werden kann, hier eine kleine Aufgabe.\n\nWir wollen haben:\n-\
    \ Eine Variable namens `message` mit dem Inhalt der Nachricht \"Nach Hause telefonieren\"\
    ,\n- eine Variable namens `number_messages` mit einer bisherigen Anzahl von f\xFC\
    nf als Integer (int),\n- Die Ausgabe der Nachricht, wenn die Anzahl der bisherigen\
    \ Nachricht kleiner als die maximale Anzahl der Nachrichten ist."
  title: Kurze Wiederholung
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Ne. Das sieht ja gar nicht gut aus...'
        elif ('[1, 2, 3]' in output and 'zahlen' in scope.keys() and
             scope['zahlen'] == [1,2,3]):
            return True, 'Supiiiiiiii.'
        else:
            return False, 'Ja. Aber auch nein. Eher nein.'
  code: |-
    zahlen = []
    print(zahlen)
  id: 13
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt sind normalerweise ja aber mehr als ein Nutzer unterwegs.\nOder mehr\
    \ als eine Person geht in ein Restaurant.\nOder es werden verschiedene Gerichte\
    \ gegessen, die unterschiedlich viel kosten.\n\nWir wollen aber nicht f\xFCr jeden\
    \ einzelnen Wert eine neue Variable erstellen. Manchmal wissen wir am Anfang ja\
    \ auch noch gar nicht, wie viele Werte wir am Ende haben. Daf\xFCr gibt es: *Listen*.\n\
    Aufregend. In Python \xFCblicherweise `list`.\n\nEine Liste ist genau das was\
    \ es sagt: Eine Liste von Werten. Aber, aber. Diese Liste selbst ist jetzt die\
    \ Variable. Und diese Variable h\xE4lt keine, eine, oder mehrere Werte. Das k\xF6\
    nnen sogar unterschiedliche Typen sein, aber das lassen wir lieber sein. Mir ist\
    \ noch kein Fall untergekommen wo das praktisch sein soll. Aber irgendwo wird\
    \ es da sicher etwas f\xFCr geben. Wir bleiben mal bei Listen von einem Typ.\n\
    \nEine Liste sieht dann beispielsweise so aus:\n```\nkosten = [5, 3, 5, 7]\n```\n\
    \nEs k\xF6nnen so viele Elemente wie wir wollen da rein - naja... zumindest bis\
    \ der Speicher voll ist - und die Werte k\xF6nnen auch gleich sein. Wir k\xF6\
    nnen zweimal eine 5 reinpacken.\n\nUm dann auf ein Element zuzugreifen benutzen\
    \ wir wieder `[]`. Und zwar w\xE4re `kosten[0]` gleich `5`. Das ist das erste\
    \ Element. Wir sehen: Wir fangen bei 0 an zu z\xE4hlen. Hat sich mal jemand so\
    \ ausgedacht... Ist nicht bei allen Programmiersprachen so, aber grunds\xE4tzlich\
    \ w\xFCrde ich davon ausgehen, weil die meisten schon bei 0 anfangen.\n\nDann\
    \ k\xF6nnen wir durchgehen und die jeweiligen Elemente ansprechen. Also \n```\n\
    kosten[0] # 5\nkosten[1] # 3\nkosten[2] # 5\nkosten[3] # 7\n```\n\nWenn wir versuchen\
    \ auf das f\xFCnfte Element zuzugreifen mit `kosten[4]` dann findet Pythone das\
    \ nicht lustig und gibt einen Fehler aus. Ist ja schlie\xDFlich nichts drin. Wenn\
    \ wir manchmal aber einfach vergessen haben - das Alter und so - wie viele Elemente\
    \ wir in der Liste haben, dann k\xF6nnen wir mit `kosten[-1]` auf das letzte Element,\
    \ und mit `-4` wieder auf das erste Element zugreifen. Zumindest in Python (das\
    \ geht in eher wenigen Programmiersprachen).\n\nUm eine leere Liste zu initialisieren\
    \ und die Elemente schrittweise hinzuzuf\xFCgen schreiben wir einfach:\n```\n\
    kosten = []\nkosten.append(5)\nkosten.append(3)\nkosten.append(5)\nkosten.append(7)\n\
    ```\n\nIst mehr Schreibarbeit, aber auch flexibler, weil wir erst im sp\xE4teren\
    \ Verlauf des Programms die Elemente hinzuf\xFCgen k\xF6nnen.\n\n### Praxis\n\
    Viel Input... Also gehts jetzt mal ran, damit das ganze auch ein wenig h\xE4ngen\
    \ bleibt.\n\nWir fangen mit einer einfach Liste an. Die Variable `zahlen` muss\
    \ die Werte `1`, `2` und `3` beinhalten. In dieser Reihenfolge. Reihenfolge ist\
    \ n\xE4mlich wichtig."
  title: Listen
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Puff.'\n    elif 'schuhe' in scope.keys() and scope['schuhe'] == [51,\
    \ 46, 52, 53, 46, 37]:\n        return True, 'Die haben aber kleine F\xFC\xDF\
    e.'\n    else:\n        return False, 'So knapp. Vielleicht. Vielleicht aber auch\
    \ nicht.'"
  code: '# Hier koennte Dein Code stehen'
  id: 14
  output: ''
  response:
    display: none
    message: ''
  text: "Und jetzt brauchen wir eine Liste mit dem Namen `schuhe` f\xFCr die Schuhgr\xF6\
    \xDFen in einem durchschnittlichen Kindergarten.\nDiese haben die Werte:\n- 51\n\
    - 46\n- 52\n- 53\n- 46\n- 37"
  title: Liste 2
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Oh oh. Da ist wohl viel schief gelaufen.'\n    elif ('user' in scope.keys()\
    \ and \n        scope['user'] == ['Herbert', 'Gerda', 'Renate', 'Udo', 'Bodo']):\n\
    \        return True, 'So sieht ein Club der jungen Menschen aus.'\n    else:\n\
    \        return False, 'Oh oh. Da ist wohl etwas schief gelaufen.'"
  code: '# Hier koennte Dein Code stehen'
  id: 15
  output: ''
  response:
    display: none
    message: ''
  text: "Aber Listen k\xF6nnen nat\xFCrlich auch noch etwas anderes beinhalten als\
    \ Zahlen. Zum Beispiel die Liste der `user`:\n- Herbert\n- Gerda\n- Renate\n-\
    \ Udo\n- Bodo"
  title: Liste 3
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Puff.'
        elif 'numbers' in scope.keys() and '22' in output and scope['numbers'][3] == 22:
            return True, 'Piu Piu.'
        else:
            return False, 'Naaaaaaa. Neeeee.'
  code: |-
    numbers = [8, 29, 37, 22, 19, 23, 12, 26, 40, 20]
    print()
  id: 16
  output: ''
  response:
    display: none
    message: ''
  text: Und jetzt wollen wir das vierte Element der gegebenen Liste `numbers` (kreativ,
    nicht?) ausgeben.
  title: Liste 4
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Nope. Das sieht gar nicht gut aus.'
        elif '3\n2\n1\n' in output and scope['numbers'] == [3, 2, 1]:
            return True, 'Ganz genau so geht das.'
        else:
            return False, 'Nope. Das ist es noch nicht.'
  code: |-
    numbers = []  # Sollte wohl was in der Liste sein
    for number in numbers:  # number ist jetzt die jeweilige Zahl
      print()  # Hier fehlt relativ wahrscheinlich auch noch was
  id: 17
  output: ''
  response:
    display: none
    message: ''
  text: "Warum Listen auch noch aufregend sind? Weil wir Dinge dadurch f\xFCr jedes\
    \ Element in einer Liste etwas Bestimmtes machen k\xF6nnen. Klingt jetzt erstmal\
    \ kompliziert, ist aber eigentlich ganz simpel.\n\nDas Prinzip ist so:\n- Wir\
    \ haben eine Liste.\n- Wir gehen durch die Liste durch.\n- Wir machen etwas mit\
    \ dem Element der Liste.\n\nUnd das machen wir mit einem `for`-Loop. Das sieht\
    \ typischerweise so aus:\n```\nfor e in [1, 2, 3]:\n  print(e)  # Oder mach was\
    \ anderes...\n```\n\nWichtig ist hier wieder das richtige Einr\xFCcken. Und ab\
    \ dann habne wir im ersten Loop, dass `e` gleich `1` ist und danach `2` und danach\
    \ `3`. Eigentlich ganz \xFCbersichtlich.\n\nDamit das aber nicht so festgeschrieben\
    \ ist benutzen wir wieder eine Liste `numbers`. Die gehen wir durch und geben\
    \ die Elemente aus. Wir wollen f\xFCr den Anfang die Elemente `3`, `2`, `1` ausgeben,\
    \ jeweils in einer Zeile und in der Reihenfolge."
  title: Immer im Kreis
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Puff. Explosion.'\n    elif ('True' in output and 'var' in scope.keys()\
    \ and 'result' in scope.keys() and\n        scope['var'] == 1.5 and scope['var']\
    \ == scope['result']):\n        return True, 'Pille Palle.'\n    elif '1.5' in\
    \ output:\n        return False, 'Sehr gut. Legales schummeln. Technik, die begeistert.'\n\
    \    else:\n        return False, 'N\xE4\xE4\xE4\xE4\xE4\xE4\xE4.'"
  code: |-
    var = 1.0
    var += 2.0
    var *= 3.0
    var -= 4.5
    var /= 3.0

    result = 0.0  # Diesen Wert ersetzen

    print(var == result)
  id: 18
  output: ''
  response:
    display: none
    message: ''
  text: "Jetzt k\xF6nnen wir Sachen im Kreis machen und damit ja ein bisschen rumspielen.\n\
    \nDamit wir etwas Aufregendes und h\xE4ufig Genutztes machen k\xF6nnen, hier ein\
    \ kleines Zwischenspiel.\nWenn wir eine Variable haben, eine Zahl oder einen Text,\
    \ dann k\xF6nnen wir den ver\xE4ndern.\nAlso wenn wir eine Zahl haben und diese\
    \ Zahl um eins erh\xF6hen wollen, dann m\xFCssen wir ja so etwas machen:\n```\n\
    i = 0\ni = i + 1\n``` \n\nDenn das `i` ist der Wert, den es vorher hatte und dazu\
    \ noch eins drauf.\n\nDasselbe Prinzip funktioniert auch mit Text:\n```\ntext\
    \ = 'Hallo'\ntext += 'lilo'\n```\n\nUnd danach ist die Variable `text` gleich\
    \ `'Hallolilo'`. Und wie uns aufgefallen ist, ist `+=` eine Abk\xFCrzung f\xFC\
    r `= variable + `. Bei Zahlen geht das ganze auch mit mal (`*=`), minus (`-=`)\
    \ und geteilt (`/=`). Das macht aber bei Text nicht ganz so viel Sinn...\n\n####\
    \ Was suchen wir?\n\nWas ist der Wert von `var` in der letzten Zeile. Nach dem\
    \ Eintragen des richtigen Wertes sollte `True` ausgegeben werden. (Statt selbst\
    \ zu rechnen, kann nat\xFCrlich vorher einmal nur der Wert von `var` ausgegebn\
    \ werden. Nachvollziehen, warum es diesen Wert hat w\xE4re aber wohl nicht verkehrt.)"
  title: Ganz nebenbei...
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Puff. Putt.'\n    elif ('True' in output and 'var' in scope.keys() and\
    \ 'result' in scope.keys() and\n        scope['var'] == 'Wer mag Kekse?' and scope['var']\
    \ == scope['result']):\n        return True, 'Daf\xFCr kann man sich schon mal\
    \ auf die Schulter klopfen.'\n    elif '1.5' in output:\n        return False,\
    \ 'Sehr gut. Wenn schummeln blo\xDF immer so einfach w\xE4re...'\n    else:\n\
    \        return False, 'Ja. Ach ne. Doch nicht. Ne.'"
  code: |-
    var = 'mag '
    var = 'Wer' + ' ' + var
    var += 'Kekse'
    var += '?'

    result = 'Blabla'  # Diesen Wert ersetzen

    print(var == result)
  id: 19
  output: ''
  response:
    display: none
    message: ''
  text: |-
    Dasselbe wollen wir auch noch einmal mit einem Text testen.
    Gleiches Prinzip wie zuvor.
  title: Texte
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Piff Paff Puff. Putt.'\n    elif ('True' in output and 'numbers' in\
    \ scope.keys() and\n        scope['numbers'] == [1, 1, 1, 2] and\n        'counter'\
    \ in scope.keys() and 'result' in scope.keys() and\n        scope['counter'] ==\
    \ 7 and scope['counter'] == scope['result']):\n        return True, 'Jop.'\n \
    \   elif '1.5' in output:\n        return False, 'Sehr gut. Wenn schummeln blo\xDF\
    \ immer so einfach w\xE4      re...'\n    else:\n        return False, 'Ja. Ach\
    \ ne. Doch nicht. Ne.'"
  code: |-
    numbers = [1, 1, 1, 2]
    counter = 2
    for number in numbers:
      counter += number

    result = 0
    print(result == number)
  id: 20
  output: ''
  response:
    display: none
    message: ''
  text: "Kommen wir also zur\xFCck zu den Kreisen.\nWelchen Wert hat der `counter`\
    \ am Ende?"
  title: Wieder Kreise
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Das mochte Python nun gar nicht leiden.'\n    elif ('True' in output\
    \ and 'messages' in scope.keys() and\n        len(scope['messages']) == 4 and\n\
    \        scope['messages'][2] == 'Moin Berta' and\n        'bertas_index' in scope.keys()\
    \ and 'bertas_message' in scope.keys() and\n        scope['bertas_index'] == 2\
    \ and scope['bertas_message'] == 'Moin Berta'):\n        return True, 'War das\
    \ nicht... Einfach?'\n    else:\n        return False, 'N\xF6. Vielleicht nah\
    \ dran. Vielleicht nicht. Wir werden es nie erfahren.'"
  code: |-
    user = ['Simone', 'Alf', 'Berta', 'Thorsten']
    hello_message = 'Moin '

    messages = []
    for u in user:
      messages.append(hello_message + u)

    bertas_message = 'Hallo Alf'
    bertas_index = 1
    print(messages[bertas_index] == bertas_message)
  id: 21
  output: ''
  response:
    display: none
    message: ''
  text: "Damit haben wir eigentlich genug, um beispielsweise bei einer automatisierten\
    \ E-Mail ein wenig Pers\xF6nlichkeit vorzugaukeln.\n\nHier werden wir ein wenig\
    \ komplexer.\n\nWas ist Bertas Nachricht am Ende und an welcher Stelle steht diese\
    \ Nachricht?\nEs hilft Schritt f\xFCr Schritt durch den Code zu gehen, vielleicht\
    \ sogar alles auf einen Zettel aufzuschreiben. Ein lockeres: Wenn das, dann hier\
    \ so, deshalb das da und dann ist das hier drin, weshalb das so."
  title: Ein wenig was vorgaukeln
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Das sieht nicht gut aus.'
        elif 'Moin Inge\nMoin Siegfried' in output:
            return True, 'Toller Start.'
        else:
            return False, 'Das sieht mir etwas zu orange aus.'
  code: |-
    def say_hello(hello, users):
      for u in users:
        print(hello + u)

    user = ['Otto', 'Judit']
    say_hello('Huhu ', user)

    say_hello('Servus ', ['Horst', 'Ute'])  # Zeile aendern
  id: 22
  output: ''
  response:
    display: none
    message: ''
  text: "Im Prinzip war jetzt alles dabei, was mal in allen \xFCblichen Programmen\
    \ so vorkommt. Aber eine wichtige Sache noch nicht. Und das sind Funktionen. Die\
    \ m\xFCssen leider noch sein. Bisher m\xFCssten wir, wenn wir etwas Kompliziertes\
    \ schreiben, wirklich alles untereinander schreiben. Auch, wenn wir leicht ver\xE4\
    nderte Werte nutzen w\xFCrden.\n\nNehmen wir daf\xFCr folgendes (leicht konstruiertes)\
    \ Beispiel.\n```\nuser = ['Otto', 'Judit']\nhello = 'Huhu '\nfor u in user:\n\
    \  print(hello + u)\n\nhello = 'Moin '\nfor u in user:\n  print(hello + u)\n\n\
    hello = 'Servus '\nfor u in user:\n  print(hello + u) \n```\n\nDas meiste davon\
    \ sieht irgendwie so aus, als w\xFCrde es exakt dasselbe machen, aber andere Werte\
    \ brauchen. Jetzt sind wir nat\xFCrlich faul. Ich tippe den ganzen Quatsch zumindest\
    \ nicht nochmal ab, nur weil jemand anders begr\xFC\xDFt werden m\xF6chte.\n\n\
    Daf\xFCr gibt es jetzt Funktionen. Die sehen immer so aus:\n```\ndef name(hier,\
    \ dort, und):\n  print('huhu')  # Hier passiert etwas\n```\n\nund die k\xF6nnen\
    \ dann aufgerufen mit `name(1, 2, 3)` aufgerufen werden.\n\n#### Praxis\nWir haben\
    \ da aber mal etwas vorbereitet, sagte der Koch in der Show. Damit das alles etwas\
    \ plausibler wird. Einfach mal ausf\xFChren und ein bisschen was \xE4ndern, um\
    \ zu schauen was passiert.\n\nWas muss in der letzten Zeile ge\xE4ndert werden,\
    \ damit\n```\nMoin Inge\nMoin Siegried\n```\nausgegeben wird?"
  title: Noch eins
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Rot ist tot.'
        elif ('Roflkopter' in output and
            'ausgabe' in scope.keys() and scope['ausgabe'] == 'Roflkopter'):
            return True, 'War ja auch logisch.'
        else:
            return False, 'Kurz davor ist leider immer noch falsch.'
  code: |-
    def hi():
      print('Roflkopter')


    hi()
    ausgabe = '42'

    # hi() koennte so oft aufgerufen werden wie wir wollen
  id: 23
  output: ''
  response:
    display: none
    message: ''
  text: "Die Dinger werden so h\xE4ufig benutzt, dass wir damit jetzt etwas herumspielen\
    \ m\xFCssen.\nWir brauchen auch gar keine Argumente in der Funktion. Also die\
    \ Teile in den Klammern neben dem Funktionsnamen.\n\nWie hier zum Beispiel. Was\
    \ wird hier ausgegeben? (`ausgabe` auf den richtigen Wert setzen)"
  title: Variation A
- check: |-
    def _Check(scope, output):
        if 'Traceback' in output:
            return False, 'Das mochte Python nun gar nicht leiden.'
        elif ('True' in output and 'two' in scope.keys() and
            'add_one' in scope.keys() and 'a' in scope.keys() and
            'value' in scope.keys() and 'result' in scope.keys() and
            scope['value'] == 5 and scope['value'] == scope['result']):
            return True, 'Ja. Genau. Gut, gut.'
        else:
            return False, 'Ha ha ha. Neeeee.'
  code: |-
    def two():
      return 2

    def add_one(e):
      return e + 1

    a = 5
    value = 1 + add_one(a - two())

    result = 0
    print(value == result)
  id: 24
  output: ''
  response:
    display: none
    message: ''
  text: "Und dann gibt es da noch etwas ganz hilfreiches. Stell Dir mal vor, dass\
    \ Du die zusammengesetzten Nachrichten nicht sofort ausgegeben m\xF6chtest, sondern\
    \ sie nur abspeichern willst, oder sp\xE4ter noch ver\xE4ndern m\xF6chtest.\n\n\
    F\xFCr so etwas gibt es R\xFCckgabewerte (return values) und damit k\xF6nnen wir\
    \ ganz geschickte Sachen machen.\n\nEin simples Beispiel f\xFCr einen R\xFCckgabewert\
    \ w\xE4re\n```\ndef immer_zwei():\n  return 2\n\nzwei = immer_zwei()\n```\n\n\
    Ab jetzt kann der Funktionsaufruf genau so wie eine Variable benutzt werden. Nur,\
    \ dass sie eben vorher alles innerhalb der Funktion macht. Etwas aufregender,\
    \ aber noch immer nicht so richtig, w\xE4re zum Beispiel\n```\ndef plus_eins(var):\n\
    \  return var + 1\n\na = 2\nb = 3\nc = plus_eins(a) + b\n```\n\nDas wird nat\xFC\
    rlich schnell wirr... Also machen wir es wirrer (und verschaltelter) und fragen\
    \ einfach mal nach dem Wert von `value`."
  title: Variation B
- check: "def _Check(scope, output):\n    if 'Traceback' in output:\n        return\
    \ False, 'Also mit einem Fehler geht das ja nicht...'\n    else:\n        return\
    \ True, 'Herzlichen Gl\xFChstrumpf. Weiter geht es leider nicht...'"
  code: |-
    gerichte = []
    gerichte.append(10)  # Kosten vom ersten Gericht (10)
    gerichte.append(15)  # Kosten vom zweiten
    gerichte.append(8)   # Kosten vom dritten

    mitesser = 4  # Anzahl der Mitessenden
    kosten = gesamt_kosten(gerichte, mitesser)  # Berechne die Gesamtkosten aus
    print(kosten)  # Gebe die Kosten aus
  id: 25
  output: ''
  response:
    display: none
    message: ''
  text: "Und jetzt sind wir haben wir irgendwie alles, was wir brauchen, damit wir\
    \ das Beispiel vom Anfang bauen k\xF6nnen.\n\nIch hoffe der folgende Code steht\
    \ noch im global Code Fenster:\n```\ndef gesamt_kosten(gerichte, anzahl):\n  \
    \  betrag = 0.0\n    for kosten in gerichte:\n        betrag += kosten\n    if\
    \ betrag <= 0.0:\n        return 0.0\n    return betrag / anzahl\n```\n\nHoffentlich\
    \ ergibt der gr\xF6\xDFte Teil davon jetzt Sinn.\n\n1. Wir haben eine Funktion\
    \ namens `gesamt_kosten`, der man eine Liste an Gerichten \xFCbergibt und dann\
    \ noch sagt, durch wie viele Leute der Betrag geteilt werden soll.\n2. Dann summieren\
    \ wir den Betrag auf und teilen ihn durch die Anzahl.\n3. Wenn allerdings die\
    \ Summe negativ ist (vielleicht weil ein Depp negative Werte \xFCbergeben hat),\
    \ dann geben wir `0.0` zur\xFCck.\n\nUnd damit sollte auch der Code weiter unten\
    \ Sinn ergeben. Erst sammeln wir die Kosten, dann rechnen wir alles aus und dann\
    \ geben wir den Betrag pro Person aus.\n\nSo ist das mit den Crash-Kursen..."
  title: Finale
global-code: ''
passed: 0
title: Starterpack
